<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNITARES Governance Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <!-- Dashboard styles (extracted) -->
    <link rel="stylesheet" href="/dashboard/styles.css">
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Dashboard utilities -->
    <script src="/dashboard/utils.js"></script>
    <script src="/dashboard/components.js"></script>
</head>

<body>
    <div class="header">
        <h1>UNITARES Governance</h1>
        <div class="subtitle">Multi-Agent Coordination Dashboard</div>
    </div>

    <div id="connection-banner" class="banner hidden"></div>

    <div class="toolbar">
        <div class="toolbar-group">
            <button id="refresh-now" class="toolbar-button" type="button">Refresh now</button>
            <label class="toolbar-toggle">
                <input id="pause-refresh" type="checkbox">
                Pause auto-refresh
            </label>
            <button id="theme-toggle" class="theme-toggle" type="button" title="Toggle theme">
                <span id="theme-icon">ðŸŒ™</span>
                <span id="theme-label">Dark</span>
            </button>
        </div>
        <div class="toolbar-status">
            <span id="refresh-status">Auto-refresh every 10 seconds</span> â€¢ Last updated: <span
                id="last-update">-</span>
        </div>
    </div>

    <div id="error-container"></div>

    <div class="stats-grid">
        <div class="stat-card">
            <h3>Total Agents</h3>
            <div class="value" id="total-agents">-</div>
            <div class="change" id="agents-change"></div>
        </div>
        <div class="stat-card">
            <h3>Active Agents</h3>
            <div class="value" id="active-agents">-</div>
            <div class="change" id="active-change"></div>
        </div>
        <div class="stat-card">
            <h3>Knowledge Discoveries</h3>
            <div class="value" id="discoveries-count">-</div>
            <div class="change" id="discoveries-change"></div>
        </div>
        <div class="stat-card">
            <h3>Dialectic Sessions</h3>
            <div class="value" id="dialectic-sessions">-</div>
            <div class="change" id="dialectic-change"></div>
        </div>
    </div>

    <div class="main-content">
        <!-- Left Column: Agents -->
        <div class="panel agents-panel">
            <div class="panel-header">
                <h2>Agents</h2>
                <div class="panel-controls">
                    <input id="agent-search" type="text" placeholder="Search agents">
                    <select id="agent-status-filter">
                        <option value="all">All statuses</option>
                        <option value="active">Active</option>
                        <option value="waiting_input">Waiting input</option>
                        <option value="paused">Paused</option>
                        <option value="archived">Archived</option>
                        <option value="deleted">Deleted</option>
                        <option value="unknown">Unknown</option>
                    </select>
                    <label>
                        <input id="agent-metrics-only" type="checkbox">
                        Metrics only
                    </label>
                    <div class="export-buttons">
                        <button id="export-agents-csv" class="export-button" type="button" title="Export as CSV">ðŸ“¥ CSV</button>
                        <button id="export-agents-json" class="export-button" type="button" title="Export as JSON">ðŸ“¥ JSON</button>
                    </div>
                    <button id="agent-clear-filters" class="panel-button" type="button">Clear</button>
                </div>
            </div>
            <div id="agents-filter-info" class="filter-info"></div>
            <div id="agents-status-legend" class="filter-info"></div>
            <div id="agents-container" class="agent-list">
                <div class="loading">Loading agents...</div>
            </div>
        </div>

        <!-- Right Column: Discoveries -->
        <div class="panel">
            <div class="panel-header">
                <h2>Recent Discoveries</h2>
                <div class="panel-controls">
                    <input id="discovery-search" type="text" placeholder="Search">
                    <select id="discovery-type-filter">
                        <option value="all">All types</option>
                        <option value="insight">Insight</option>
                        <option value="improvement">Improvement</option>
                        <option value="bug_found">Bug found</option>
                        <option value="pattern">Pattern</option>
                        <option value="question">Question</option>
                        <option value="answer">Answer</option>
                        <option value="analysis">Analysis</option>
                        <option value="note">Note</option>
                        <option value="exploration">Exploration</option>
                    </select>
                    <select id="discovery-time-filter">
                        <option value="all">All time</option>
                        <option value="24h">Last 24h</option>
                        <option value="7d">Last 7 days</option>
                        <option value="30d">Last 30 days</option>
                    </select>
                    <button id="discovery-clear-filters" class="panel-button" type="button">Clear</button>
                </div>
            </div>
            <div id="discoveries-filter-info" class="filter-info"></div>
            <div id="discoveries-type-legend" class="filter-info"></div>
            <div id="discoveries-container" class="discoveries-list">
                <div class="loading">Loading discoveries...</div>
            </div>
        </div>
    </div>

    <!-- Dialectic Sessions - Full width centered -->
    <div class="dialectic-section">
        <div class="panel">
            <div class="panel-header">
                <h2>Dialectic Sessions</h2>
                <div class="panel-controls">
                    <select id="dialectic-status-filter">
                        <option value="substantive">Substantive (3+ msgs)</option>
                        <option value="all">All sessions</option>
                        <option value="active">Active</option>
                        <option value="resolved">Resolved</option>
                        <option value="failed">Failed</option>
                    </select>
                    <button id="dialectic-refresh" class="panel-button" type="button">Refresh</button>
                </div>
            </div>
            <div id="dialectic-filter-info" class="filter-info"></div>
            <div id="dialectic-container" class="dialectic-list">
                <div class="loading">Loading dialectic sessions...</div>
            </div>
        </div>
    </div>

    <div class="refresh-info">
        Tip: use search and filters to narrow results quickly.
    </div>

    <!-- Detail modal for expandable items -->
    <div id="panel-modal" class="panel-modal-overlay">
        <div class="panel-modal">
            <div class="panel-modal-header">
                <h2 id="modal-title">Panel</h2>
                <button class="panel-modal-close">&times;</button>
            </div>
            <div class="panel-modal-body" id="modal-body">
                <!-- Content injected by JS -->
            </div>
        </div>
    </div>

    <script>
        // Wait for utilities to load
        if (typeof DashboardAPI === 'undefined' || typeof DataProcessor === 'undefined' || typeof ThemeManager === 'undefined') {
            console.error('Dashboard utilities not loaded. Make sure utils.js and components.js are accessible.');
        }

        // Initialize utilities
        const api = typeof DashboardAPI !== 'undefined' ? new DashboardAPI(window.location.origin) : null;
        const themeManager = typeof ThemeManager !== 'undefined' ? new ThemeManager() : null;
        const REFRESH_INTERVAL_MS = 10000;
        let previousStats = {};
        let cachedAgents = [];
        let cachedDiscoveries = [];
        let autoRefreshPaused = false;
        let refreshFailures = 0;
        const maxRefreshFailures = 2;

        // Modal functions for expandable panels
        function expandPanel(panelType) {
            const modal = document.getElementById('panel-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            if (panelType === 'discoveries') {
                modalTitle.textContent = `Recent Discoveries (${cachedDiscoveries.length})`;
                modalBody.innerHTML = renderDiscoveriesForModal(cachedDiscoveries);
            } else if (panelType === 'dialectic') {
                modalTitle.textContent = `Dialectic Sessions (${cachedDialecticSessions.length})`;
                modalBody.innerHTML = renderDialecticForModal(cachedDialecticSessions);
            }

            modal.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }

        function closeModal() {
            const modal = document.getElementById('panel-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            document.body.style.overflow = '';
        }

        // Close modal on escape or click outside
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();
        });
        document.getElementById('panel-modal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('panel-modal-overlay')) closeModal();
        });
        // Close button handler
        document.querySelector('.panel-modal-close')?.addEventListener('click', closeModal);

        function renderDiscoveriesForModal(discoveries) {
            if (!discoveries || discoveries.length === 0) {
                return '<div class="loading">No discoveries found</div>';
            }

            const escapeHtml = (str) => {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');
            };

            return `<div class="discoveries-list">${discoveries.map(d => {
                const type = d.type || d.discovery_type || 'note';
                const summary = d.summary || d.title || 'Untitled';
                const content = d.content || d.details || '';
                const agent = d.agent_id || d.agent || 'Unknown';
                const time = d.timestamp || d.created_at || '';

                return `
                    <div class="discovery-item">
                        <div class="discovery-header">
                            <span class="discovery-type">${escapeHtml(type)}</span>
                            <span class="discovery-time">${escapeHtml(time)}</span>
                        </div>
                        <div class="discovery-summary">${escapeHtml(summary)}</div>
                        ${content ? `<div class="discovery-content" style="margin-top: 8px; font-size: 0.9em; color: var(--text-secondary);">${escapeHtml(content)}</div>` : ''}
                        <div class="discovery-meta" style="margin-top: 8px; font-size: 0.8em; color: var(--text-secondary);">
                            Agent: ${escapeHtml(agent.length > 20 ? agent.substring(0, 20) + '...' : agent)}
                        </div>
                    </div>
                `;
            }).join('')}</div>`;
        }

        function renderDialecticForModal(sessions) {
            if (!sessions || sessions.length === 0) {
                return '<div class="loading">No dialectic sessions found</div>';
            }

            const escapeHtml = (str) => {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');
            };

            return `<div class="dialectic-list">${sessions.map(session => {
                const phase = session.phase || session.status || 'unknown';
                const phaseColor = getPhaseColor(phase);
                const requestorId = session.paused_agent || session.requestor_id || 'Unknown';
                const reviewerId = session.reviewer || session.reviewer_id || 'None';
                const sessionType = session.session_type || session.type || 'verification';
                const topic = session.topic || session.reason || `${sessionType} session`;
                const created = session.created || session.created_at || '';
                const sessionId = session.session_id || 'unknown';

                return `
                    <div class="dialectic-item ${phase}">
                        <div class="dialectic-header">
                            <span class="dialectic-type" style="border-color: ${phaseColor}; color: ${phaseColor}">
                                ${escapeHtml(formatDialecticPhase(phase))}
                            </span>
                            <span class="dialectic-session-type">${escapeHtml(sessionType)}</span>
                            <span class="dialectic-time">${escapeHtml(created)}</span>
                        </div>
                        <div class="dialectic-topic">${escapeHtml(topic)}</div>
                        <div class="dialectic-agents">
                            <span class="agent-label">Session:</span> ${escapeHtml(sessionId)}
                        </div>
                        <div class="dialectic-agents" style="margin-top: 4px;">
                            <span class="agent-label">Requestor:</span> ${escapeHtml(requestorId)}
                            ${reviewerId && reviewerId !== 'None' ? `<span class="agent-label">Reviewer:</span> ${escapeHtml(reviewerId)}` : ''}
                        </div>
                    </div>
                `;
            }).join('')}</div>`;
        }

        // Use new API utility or fallback to old implementation
        async function callTool(toolName, toolArguments = {}, options = {}) {
            // Use 'toolArguments' instead of 'arguments' to avoid reserved word issues
            if (api) {
                try {
                    return await api.callTool(toolName, toolArguments, options);
                } catch (error) {
                    console.error(`Error calling ${toolName}:`, error);
                    throw error;
                }
            } else {
                // Fallback to old implementation if utilities not loaded
                console.warn('Using fallback API implementation - utilities not loaded');
                return await callToolFallback(toolName, toolArguments);
            }
        }

        // Fallback implementation
        async function callToolFallback(toolName, toolArguments = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                };
                
                const apiToken = localStorage.getItem('unitares_api_token') || 
                                 new URLSearchParams(window.location.search).get('token');
                if (apiToken) {
                    headers['Authorization'] = `Bearer ${apiToken}`;
                }
                
                // Ensure toolArguments is an object
                if (!toolArguments || typeof toolArguments !== 'object') {
                    toolArguments = {};
                }
                
                const requestBody = {
                    name: String(toolName || ''),
                    arguments: toolArguments
                };
                
                console.log('Sending request:', { toolName, toolArguments: Object.keys(toolArguments) });
                
                const requestBodyStr = JSON.stringify(requestBody);
                console.log(`[Fallback API] Calling ${toolName}:`, requestBodyStr.substring(0, 200));
                
                const response = await fetch(`${window.location.origin}/v1/tools/call`, {
                    method: 'POST',
                    headers: headers,
                    body: requestBodyStr,
                    signal: AbortSignal.timeout(30000)
                });

                const responseText = await response.text();
                console.log(`[Fallback API] Response: ${response.status}`, responseText.substring(0, 200));

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    
                    try {
                        const errorData = JSON.parse(responseText);
                        if (errorData.error) {
                            errorMessage = errorData.error;
                        }
                    } catch {
                        // Not JSON, use text as-is
                        if (responseText) {
                            errorMessage = responseText.substring(0, 200);
                        }
                    }
                    
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('[Fallback API] Failed to parse response:', responseText.substring(0, 200));
                    throw new Error(`Invalid JSON response: ${parseError.message}`);
                }
                
                if (data.success === false || data.error) {
                    throw new Error(data.error || data.message || 'Tool call failed');
                }

                // Handle result - could be string JSON or already parsed
                if (typeof data.result === 'string') {
                    try {
                        return JSON.parse(data.result);
                    } catch (parseError) {
                        console.warn('[Fallback API] Result is string but not valid JSON');
                        return data.result;
                    }
                }
                return data.result;
            } catch (error) {
                console.error(`Error calling ${toolName}:`, error);
                throw error;
            }
        }

        // Use DataProcessor utilities or fallback
        const escapeHtml = typeof DataProcessor !== 'undefined' && DataProcessor.escapeHtml ? DataProcessor.escapeHtml : function(value) {
            return String(value || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };
        
        const highlightMatch = typeof DataProcessor !== 'undefined' && DataProcessor.highlightMatch ? DataProcessor.highlightMatch : function(text, term) {
            if (!term) return escapeHtml(text);
            const safeText = String(text || '');
            const safeTerm = String(term || '').trim();
            if (!safeTerm) return escapeHtml(safeText);
            const escapedTerm = safeTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedTerm, 'ig');
            let result = '';
            let lastIndex = 0;
            let match;
            while ((match = regex.exec(safeText)) !== null) {
                result += escapeHtml(safeText.slice(lastIndex, match.index));
                result += `<mark class="highlight">${escapeHtml(match[0])}</mark>`;
                lastIndex = match.index + match[0].length;
            }
            result += escapeHtml(safeText.slice(lastIndex));
            return result;
        };
        
        const copyToClipboard = typeof DataProcessor !== 'undefined' && DataProcessor.copyToClipboard ? DataProcessor.copyToClipboard : async function(text) {
            if (navigator.clipboard && window.isSecureContext) {
                return navigator.clipboard.writeText(text);
            }
            return new Promise((resolve, reject) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.select();
                try {
                    const success = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    if (success) resolve();
                    else reject(new Error('Copy failed'));
                } catch (error) {
                    document.body.removeChild(textarea);
                    reject(error);
                }
            });
        };
        
        const formatRelativeTime = typeof DataProcessor !== 'undefined' && DataProcessor.formatRelativeTime ? DataProcessor.formatRelativeTime : function(timestampMs) {
            if (!timestampMs) return null;
            const diffMs = Date.now() - timestampMs;
            if (diffMs <= 0) return 'just now';
            const seconds = Math.floor(diffMs / 1000);
            if (seconds < 60) return `${seconds}s ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            if (days < 7) return `${days}d ago`;
            const weeks = Math.floor(days / 7);
            if (weeks < 5) return `${weeks}w ago`;
            const months = Math.floor(days / 30);
            if (months < 12) return `${months}mo ago`;
            const years = Math.floor(days / 365);
            return `${years}y ago`;
        };
        
        const formatTimestamp = typeof DataProcessor !== 'undefined' && DataProcessor.formatTimestamp ? DataProcessor.formatTimestamp : function(timestamp) {
            if (!timestamp) return null;
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return null;
            return date.toLocaleString();
        };

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">Error: ${escapeHtml(message)}</div>`;
        }

        function clearError() {
            document.getElementById('error-container').innerHTML = '';
        }

        function formatChange(current, previous) {
            if (previous === undefined || previous === null) return '';
            const diff = current - previous;
            if (diff === 0) return '';
            const sign = diff > 0 ? '+' : '';
            const color = diff > 0 ? '#4ade80' : '#ff6b6b';
            return `<span style="color: ${color}">${sign}${diff}</span>`;
        }

        function updateConnectionBanner(hasError) {
            const banner = document.getElementById('connection-banner');
            if (!banner) return;
            if (hasError) {
                refreshFailures += 1;
            } else {
                // Reset on success, but only if we had failures
                if (refreshFailures > 0) {
                    refreshFailures = Math.max(0, refreshFailures - 1); // Decay failures gradually
                }
            }

            // Only show banner after multiple consecutive failures
            if (refreshFailures >= maxRefreshFailures) {
                banner.textContent = `Connection issues detected (${refreshFailures} failures). Check server status or network. Click "Refresh now" to retry.`;
                banner.classList.remove('hidden');
            } else {
                banner.classList.add('hidden');
            }
        }

        function updateRefreshStatus() {
            const status = document.getElementById('refresh-status');
            if (!status) return;
            status.textContent = autoRefreshPaused
                ? 'Auto-refresh paused'
                : `Auto-refresh every ${Math.round(REFRESH_INTERVAL_MS / 1000)} seconds`;
        }

        function getAgentStatus(agent) {
            return agent.lifecycle_status || agent.status || 'unknown';
        }

        function getAgentDisplayName(agent) {
            return agent.label || agent.display_name || agent.name || agent.agent_id || 'Unknown';
        }

        function agentHasMetrics(agent) {
            const metrics = agent.metrics || {};
            return metrics && (metrics.E !== undefined || metrics.I !== undefined || metrics.S !== undefined);
        }

        function formatStatusLabel(status) {
            const normalized = String(status || 'unknown').toLowerCase();
            const labels = {
                active: 'Active',
                waiting_input: 'Waiting',
                paused: 'Paused',
                archived: 'Archived',
                deleted: 'Deleted',
                unknown: 'Unknown'
            };
            return labels[normalized] || normalized.replace(/_/g, ' ');
        }

        // formatTimestamp and formatRelativeTime are already defined above as const variables
        // These duplicate definitions are removed to avoid conflicts

        function formatAgentTimestamp(agent) {
            const lastUpdateDate = agent.last_update ? new Date(agent.last_update) : null;
            if (lastUpdateDate && !isNaN(lastUpdateDate.getTime())) {
                const lastUpdate = lastUpdateDate.toLocaleString();
                const relative = formatRelativeTime(lastUpdateDate.getTime());
                return relative ? `Updated ${lastUpdate} (${relative})` : `Updated ${lastUpdate}`;
            }
            const createdDate = agent.created_at ? new Date(agent.created_at) : null;
            if (createdDate && !isNaN(createdDate.getTime())) {
                const created = createdDate.toLocaleString();
                const relative = formatRelativeTime(createdDate.getTime());
                return relative ? `Created ${created} (${relative})` : `Created ${created}`;
            }
            return null;
        }

        function updateStatusLegend(statusCounts) {
            const container = document.getElementById('agents-status-legend');
            if (!container) return;
            if (!statusCounts) {
                container.textContent = '';
                return;
            }

            const entries = [
                { key: 'active', label: 'Active', count: statusCounts.active || 0 },
                { key: 'waiting_input', label: 'Waiting', count: statusCounts.waiting_input || 0 },
                { key: 'paused', label: 'Paused', count: statusCounts.paused || 0 },
                { key: 'archived', label: 'Archived', count: statusCounts.archived || 0 },
                { key: 'deleted', label: 'Deleted', count: statusCounts.deleted || 0 },
                { key: 'unknown', label: 'Unknown', count: statusCounts.unknown || 0 }
            ];

            const chips = entries
                .filter(entry => entry.count > 0)
                .map(entry => `<button class="status-chip ${entry.key}" data-status="${entry.key}" type="button">${entry.label} ${entry.count}</button>`)
                .join(' ');

            container.innerHTML = chips || '';
        }

        function updateAgentFilterInfo(filteredCount) {
            const info = document.getElementById('agents-filter-info');
            if (!info) return;
            const total = cachedAgents.length;
            if (!total) {
                info.textContent = '';
                return;
            }
            if (filteredCount === 0) {
                info.textContent = `No agents match filters (${total} loaded)`;
                return;
            }
            const showingCount = Math.min(filteredCount, 20);
            info.textContent = `Showing ${showingCount} of ${filteredCount} filtered (${total} loaded)`;
        }

        function renderAgentsList(agents, searchTerm = '') {
            const container = document.getElementById('agents-container');
            if (cachedAgents.length === 0) {
                container.innerHTML = '<div class="loading">No agents found. Agents will appear here after calling onboard() or any tool.</div>';
                updateAgentFilterInfo(0);
                return;
            }

            if (agents.length === 0) {
                container.innerHTML = '<div class="loading">No agents match the current filters.</div>';
                updateAgentFilterInfo(0);
                return;
            }

            updateAgentFilterInfo(agents.length);
            container.innerHTML = agents.slice(0, 20).map(agent => {
                // Use lifecycle_status from agent object (more reliable than array membership)
                const status = getAgentStatus(agent);
                const statusClass = status === 'paused' ? 'paused' :
                    status === 'archived' ? 'archived' :
                        status === 'deleted' ? 'archived' : '';  // Deleted agents styled like archived
                const statusIndicator = `<span class="status-indicator ${status}"></span>`;
                const statusLabel = escapeHtml(formatStatusLabel(status));

                const metrics = agent.metrics || {};
                const eValue = metrics.E !== undefined && metrics.E !== null ? Number(metrics.E) : null;
                const iValue = metrics.I !== undefined && metrics.I !== null ? Number(metrics.I) : null;
                const sValue = metrics.S !== undefined && metrics.S !== null ? Number(metrics.S) : null;
                const vValue = metrics.V !== undefined && metrics.V !== null ? Number(metrics.V) : null;
                const cValue = metrics.coherence !== undefined && metrics.coherence !== null ? Number(metrics.coherence) : null;
                // EISV metrics - show all four core metrics
                const e = eValue !== null && !Number.isNaN(eValue) ? eValue.toFixed(2) : '-';
                const i = iValue !== null && !Number.isNaN(iValue) ? iValue.toFixed(2) : '-';
                const s = sValue !== null && !Number.isNaN(sValue) ? sValue.toFixed(2) : '-';
                const v = vValue !== null && !Number.isNaN(vValue) ? vValue.toFixed(2) : '-';
                const coherence = cValue !== null && !Number.isNaN(cValue) ? cValue.toFixed(2) : '-';
                const clampPercent = value => {
                    if (value === null || Number.isNaN(value)) return 0;
                    return Math.max(0, Math.min(100, value * 100));
                };
                const ePct = clampPercent(eValue);
                const iPct = clampPercent(iValue);
                const sPct = clampPercent(sValue);
                const vPct = clampPercent(vValue);
                const cPct = clampPercent(cValue);
                const displayName = getAgentDisplayName(agent);
                const agentId = agent.agent_id || '';
                const timestampLabel = formatAgentTimestamp(agent);
                const nameHtml = highlightMatch(displayName, searchTerm);
                const idHtml = searchTerm ? highlightMatch(agentId, searchTerm) : escapeHtml(agentId);
                const subtitleParts = [];
                if (timestampLabel) {
                    subtitleParts.push(escapeHtml(timestampLabel));
                }
                if (agentId) {
                    subtitleParts.push(`ID ${idHtml}`);
                }
                const subtitleHtml = subtitleParts.length ? `<div class="agent-subtitle">${subtitleParts.join(' â€¢ ')}</div>` : '';
                const actionsHtml = agentId
                    ? `<div class="agent-actions"><button class="agent-action" type="button" data-action="copy-id" data-agent-id="${escapeHtml(agentId)}">Copy ID</button></div>`
                    : '';

                // Show metrics only if we have at least one metric value
                const hasMetrics = agentHasMetrics(agent);

                return `
                    <div class="agent-item ${statusClass}">
                        <div class="agent-meta">
                            <div class="agent-title">
                                ${statusIndicator}
                                <span class="agent-name">${nameHtml}</span>
                                <span class="status-chip ${status}">${statusLabel}</span>
                                ${actionsHtml}
                            </div>
                            ${subtitleHtml}
                        </div>
                        ${hasMetrics ? `
                            <div class="agent-metrics">
                                <div class="metric e" title="Energy (divergence/productive capacity)">
                                    <div class="label">E</div>
                                    <div class="val">${e}</div>
                                    <div class="metric-bar"><div class="metric-bar-fill" style="width: ${ePct}%"></div></div>
                                </div>
                                <div class="metric i" title="Information Integrity">
                                    <div class="label">I</div>
                                    <div class="val">${i}</div>
                                    <div class="metric-bar"><div class="metric-bar-fill" style="width: ${iPct}%"></div></div>
                                </div>
                                <div class="metric s" title="Entropy (disorder/uncertainty)">
                                    <div class="label">S</div>
                                    <div class="val">${s}</div>
                                    <div class="metric-bar"><div class="metric-bar-fill" style="width: ${sPct}%"></div></div>
                                </div>
                                <div class="metric v" title="Void Integral (E-I imbalance)">
                                    <div class="label">V</div>
                                    <div class="val">${v}</div>
                                    <div class="metric-bar"><div class="metric-bar-fill" style="width: ${vPct}%"></div></div>
                                </div>
                                <div class="metric c" title="Coherence">
                                    <div class="label">C</div>
                                    <div class="val">${coherence}</div>
                                    <div class="metric-bar"><div class="metric-bar-fill" style="width: ${cPct}%"></div></div>
                                </div>
                            </div>
                        ` : '<div class="agent-metrics"><span style="color: #8a9ba8; font-size: 0.9em;">No metrics yet</span></div>'}
                    </div>
                `;
            }).join('');
        }

        function applyAgentFilters() {
            const searchInput = document.getElementById('agent-search');
            const statusFilterInput = document.getElementById('agent-status-filter');
            const metricsOnlyInput = document.getElementById('agent-metrics-only');

            const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
            const statusFilter = statusFilterInput ? statusFilterInput.value : 'all';
            const metricsOnly = metricsOnlyInput ? metricsOnlyInput.checked : false;

            const filteredAgents = cachedAgents.filter(agent => {
                const status = getAgentStatus(agent);
                if (statusFilter !== 'all' && status !== statusFilter) {
                    return false;
                }

                if (metricsOnly && !agentHasMetrics(agent)) {
                    return false;
                }

                if (searchTerm) {
                    const displayName = getAgentDisplayName(agent);
                    const agentId = agent.agent_id || '';
                    const haystack = `${displayName} ${agentId}`.toLowerCase();
                    if (!haystack.includes(searchTerm)) {
                        return false;
                    }
                }

                return true;
            });

            renderAgentsList(filteredAgents, searchTerm);
        }

        function clearAgentFilters() {
            const searchInput = document.getElementById('agent-search');
            const statusFilterInput = document.getElementById('agent-status-filter');
            const metricsOnlyInput = document.getElementById('agent-metrics-only');
            if (searchInput) searchInput.value = '';
            if (statusFilterInput) statusFilterInput.value = 'all';
            if (metricsOnlyInput) metricsOnlyInput.checked = false;
            applyAgentFilters();
        }

        function normalizeDiscoveryType(type) {
            if (!type) return 'note';
            return String(type).trim().toLowerCase();
        }

        function formatDiscoveryType(type) {
            const value = normalizeDiscoveryType(type);
            const labelMap = {
                bug_found: 'Bug',
                improvement: 'Improvement',
                insight: 'Insight',
                pattern: 'Pattern',
                question: 'Question',
                answer: 'Answer',
                note: 'Note',
                exploration: 'Exploration',
                analysis: 'Analysis'
            };
            return labelMap[value] || value.replace(/_/g, ' ');
        }

        function updateDiscoveryFilterInfo(filteredCount) {
            const info = document.getElementById('discoveries-filter-info');
            if (!info) return;
            const total = cachedDiscoveries.length;
            if (!total) {
                info.textContent = '';
                return;
            }
            if (filteredCount === 0) {
                info.textContent = `No discoveries match filters (${total} loaded)`;
                return;
            }
            const showingCount = Math.min(filteredCount, 10);
            info.textContent = `Showing ${showingCount} of ${filteredCount} filtered (${total} loaded)`;
        }

        function updateDiscoveryLegend(discoveries) {
            const container = document.getElementById('discoveries-type-legend');
            if (!container) return;
            if (!discoveries || discoveries.length === 0) {
                container.textContent = '';
                return;
            }

            const counts = {};
            discoveries.forEach(d => {
                const type = normalizeDiscoveryType(d.type || d.discovery_type || 'note');
                counts[type] = (counts[type] || 0) + 1;
            });

            const total = discoveries.length;
            const chips = [];
            chips.push(`<button class="discovery-type" data-type="all" type="button">All ${total}</button>`);

            const orderedTypes = ['insight', 'improvement', 'bug_found', 'pattern', 'question', 'answer', 'analysis', 'note', 'exploration'];
            orderedTypes.forEach(type => {
                if (!counts[type]) return;
                const label = escapeHtml(formatDiscoveryType(type));
                const count = counts[type];
                chips.push(`<button class="discovery-type ${type}" data-type="${type}" type="button">${label} ${count}</button>`);
                delete counts[type];
            });

            Object.keys(counts).sort().forEach(type => {
                const label = escapeHtml(formatDiscoveryType(type));
                const count = counts[type];
                chips.push(`<button class="discovery-type ${type}" data-type="${type}" type="button">${label} ${count}</button>`);
            });

            container.innerHTML = chips.join(' ');
        }

        function renderDiscoveriesList(discoveries, searchTerm = '') {
            const container = document.getElementById('discoveries-container');
            if (cachedDiscoveries.length === 0) {
                container.innerHTML = '<div class="loading">No recent discoveries. Use store_knowledge_graph() to add discoveries.</div>';
                updateDiscoveryFilterInfo(0);
                return;
            }

            if (discoveries.length === 0) {
                container.innerHTML = '<div class="loading">No discoveries match the current filters.</div>';
                updateDiscoveryFilterInfo(0);
                return;
            }

            updateDiscoveryFilterInfo(discoveries.length);
            const displayDiscoveries = discoveries.slice(0, 10);
            container.innerHTML = displayDiscoveries.map((d, idx) => {
                const type = normalizeDiscoveryType(d.type || d.discovery_type || 'note');
                const typeLabel = escapeHtml(formatDiscoveryType(type));
                const agent = escapeHtml(d.by || d.agent_id || d._agent_id || 'Unknown');
                const details = String(d.details || d.content || d.discovery || '');
                const summaryText = d.summary || 'Untitled';
                const summaryHtml = highlightMatch(summaryText, searchTerm);
                const detailsSnippet = details ? details.substring(0, 150) : '';
                const detailsHtml = detailsSnippet ? highlightMatch(detailsSnippet, searchTerm) : '';
                const detailsSuffix = details.length > 150 ? '...' : '';
                const relative = d._relativeTime ? ` (${d._relativeTime})` : '';
                const displayDate = escapeHtml(`${d._displayDate || 'Unknown'}${relative}`);

                return `
                    <div class="discovery-item" data-discovery-index="${idx}" style="cursor: pointer;" title="Click to view full details">
                        <div class="discoveries-meta-line">
                            <span class="discovery-type ${type}">${typeLabel}</span>
                            <span class="meta-item">By: ${agent}</span>
                            <span class="meta-item">${displayDate}</span>
                        </div>
                        <h4>${summaryHtml}</h4>
                        ${detailsHtml ? `<div class="summary">${detailsHtml}${detailsSuffix}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function applyDiscoveryFilters() {
            const searchInput = document.getElementById('discovery-search');
            const typeFilterInput = document.getElementById('discovery-type-filter');
            const timeFilterInput = document.getElementById('discovery-time-filter');
            const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
            const typeFilter = typeFilterInput ? typeFilterInput.value : 'all';
            const timeFilter = timeFilterInput ? timeFilterInput.value : 'all';
            let cutoff = null;
            if (timeFilter === '24h') {
                cutoff = Date.now() - 24 * 60 * 60 * 1000;
            } else if (timeFilter === '7d') {
                cutoff = Date.now() - 7 * 24 * 60 * 60 * 1000;
            } else if (timeFilter === '30d') {
                cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000;
            }

            const filtered = cachedDiscoveries.filter(d => {
                const type = normalizeDiscoveryType(d.type || d.discovery_type || 'note');
                if (typeFilter !== 'all' && type !== typeFilter) {
                    return false;
                }

                if (cutoff !== null) {
                    if (!d._timestampMs || d._timestampMs < cutoff) {
                        return false;
                    }
                }

                if (searchTerm) {
                    const haystack = `${d.summary || ''} ${d.details || ''} ${d.content || ''} ${d.discovery || ''}`.toLowerCase();
                    if (!haystack.includes(searchTerm)) {
                        return false;
                    }
                }

                return true;
            });

            renderDiscoveriesList(filtered, searchTerm);
        }

        function clearDiscoveryFilters() {
            const searchInput = document.getElementById('discovery-search');
            const typeFilterInput = document.getElementById('discovery-type-filter');
            const timeFilterInput = document.getElementById('discovery-time-filter');
            if (searchInput) searchInput.value = '';
            if (typeFilterInput) typeFilterInput.value = 'all';
            if (timeFilterInput) timeFilterInput.value = 'all';
            applyDiscoveryFilters();
        }

        async function loadAgents() {
            try {
                console.log('Loading agents...');
                // Use unified agent() tool with action='list'
                const result = await callTool('agent', {
                    action: 'list',
                    include_metrics: true,
                    limit: 1000,  // High limit to ensure status_counts includes all matching agents
                    status_filter: 'all'  // Get all statuses to show accurate counts
                });

                console.log('Agents result:', result);
                console.log('Result type:', typeof result);
                console.log('Result keys:', result ? Object.keys(result) : 'null');

                // Handle null/undefined result
                if (!result) {
                    throw new Error('No response from server');
                }

                // Handle rate limit errors gracefully - don't count as failure
                if (result.error && result.error.includes('rate limit')) {
                    console.warn('Rate limit hit, will retry on next refresh');
                    // Keep existing data, don't clear cache
                    return true; // Return true to not trigger connection banner
                }

                // Check for error response
                if (result.error) {
                    throw new Error(result.error);
                }

                // Handle case where result might be an array (unexpected format)
                if (Array.isArray(result)) {
                    console.warn('Unexpected array response, converting to expected format');
                    const agentsObj = {
                        active: result.filter(a => (a.lifecycle_status || a.status) === 'active'),
                        waiting_input: result.filter(a => (a.lifecycle_status || a.status) === 'waiting_input'),
                        paused: result.filter(a => (a.lifecycle_status || a.status) === 'paused'),
                        archived: result.filter(a => (a.lifecycle_status || a.status) === 'archived'),
                        deleted: result.filter(a => (a.lifecycle_status || a.status) === 'deleted'),
                        unknown: result.filter(a => !['active', 'waiting_input', 'paused', 'archived', 'deleted'].includes(a.lifecycle_status || a.status))
                    };
                    const summary = {
                        total: result.length,
                        by_status: {
                            active: agentsObj.active.length,
                            waiting_input: agentsObj.waiting_input.length,
                            paused: agentsObj.paused.length,
                            archived: agentsObj.archived.length,
                            deleted: agentsObj.deleted.length,
                            unknown: agentsObj.unknown.length
                        }
                    };
                    result = { agents: agentsObj, summary: summary };
                }

                // Parse the actual API response format
                // list_agents returns: { agents: { active: [], waiting_input: [], ... }, summary: { total: N, ... } }
                const agentsObj = result.agents || {};
                const summary = result.summary || {};
                const byStatus = summary.by_status || {};

                // Use summary counts (accurate) not array lengths (limited by pagination)
                const total = summary.total || 0;
                const active = (byStatus.active || 0) + (byStatus.waiting_input || 0);
                const paused = byStatus.paused || 0;
                const archived = byStatus.archived || 0;
                const deleted = byStatus.deleted || 0;
                const unknown = byStatus.unknown || 0;

                updateStatusLegend({
                    active: byStatus.active || 0,
                    waiting_input: byStatus.waiting_input || 0,
                    paused,
                    archived,
                    deleted,
                    unknown
                });

                // Flatten agents from all status categories (for display only)
                const allAgents = [
                    ...(agentsObj.active || []),
                    ...(agentsObj.waiting_input || []),
                    ...(agentsObj.paused || []),
                    ...(agentsObj.archived || []),
                    ...(agentsObj.deleted || []),
                    ...(agentsObj.unknown || [])
                ];

                // Update stats
                document.getElementById('total-agents').textContent = total;
                document.getElementById('active-agents').textContent = active;

                const agentsChange = formatChange(total, previousStats.totalAgents);
                // Show breakdown: active, paused, archived, deleted, unknown
                const breakdown = [];
                if (active > 0) breakdown.push(`${active} active`);
                if (paused > 0) breakdown.push(`${paused} paused`);
                if (archived > 0) breakdown.push(`${archived} archived`);
                if (deleted > 0) breakdown.push(`${deleted} deleted`);
                if (unknown > 0) breakdown.push(`${unknown} unknown`);
                document.getElementById('agents-change').innerHTML = agentsChange || (total > 0 ? breakdown.join(', ') || 'All agents' : 'No agents yet');

                const activeChange = formatChange(active, previousStats.activeAgents);
                // Show what's not active
                const inactiveBreakdown = [];
                if (paused > 0) inactiveBreakdown.push(`${paused} paused`);
                if (archived > 0) inactiveBreakdown.push(`${archived} archived`);
                if (deleted > 0) inactiveBreakdown.push(`${deleted} deleted`);
                document.getElementById('active-change').innerHTML = activeChange || (total > 0 ? (inactiveBreakdown.join(', ') || 'All active') : 'Start by calling onboard()');

                previousStats.totalAgents = total;
                previousStats.activeAgents = active;

                // Sort by last update (most recent first)
                allAgents.sort((a, b) => {
                    const aTime = new Date(a.last_update || a.created_at || 0);
                    const bTime = new Date(b.last_update || b.created_at || 0);
                    return bTime - aTime;
                });

                cachedAgents = allAgents;
                applyAgentFilters();
                return true;

            } catch (error) {
                console.error('Error loading agents:', error);
                const errorMsg = error.message || 'Unknown error';
                showError(`Failed to load agents: ${errorMsg}`);
                cachedAgents = [];
                const container = document.getElementById('agents-container');
                if (container) {
                    container.innerHTML = `<div class="loading">Error loading agents: ${escapeHtml(errorMsg)}</div>`;
                }
                updateAgentFilterInfo(0);
                updateStatusLegend(null);
                return false;
            }
        }

        async function loadDiscoveries(searchQuery = '') {
            try {
                console.log('Loading discoveries...', searchQuery ? `(search: ${searchQuery})` : '');
                // Get total count from list_knowledge_graph (only on first load or if no search)
                if (!searchQuery) {
                    try {
                        // Use unified knowledge() tool with action='stats'
                        const listResult = await callTool('knowledge', { action: 'stats' });
                        console.log('Discovery count result:', listResult);
                        const stats = listResult.stats || {};
                        const totalDiscoveries = stats.total_discoveries || 0;
                        const countEl = document.getElementById('discoveries-count');
                        if (countEl) {
                            countEl.textContent = totalDiscoveries;
                        }
                        const discoveriesChange = formatChange(totalDiscoveries, previousStats.discoveries);
                        const changeEl = document.getElementById('discoveries-change');
                        if (changeEl) {
                            changeEl.innerHTML = discoveriesChange || (totalDiscoveries > 0 ? 'Total discoveries' : 'No discoveries yet');
                        }
                        previousStats.discoveries = totalDiscoveries;
                    } catch (listError) {
                        // If list fails, show error but continue with search
                        console.warn('Failed to get discovery count:', listError);
                        const countEl = document.getElementById('discoveries-count');
                        if (countEl) {
                            countEl.textContent = '?';
                        }
                        const changeEl = document.getElementById('discoveries-change');
                        if (changeEl) {
                            changeEl.innerHTML = 'Unable to load count';
                        }
                    }
                }

                // Get discoveries using search
                // If searchQuery is present, we rely on the server validation
                const toolArgs = {
                    limit: searchQuery ? 50 : 500,  // Lower limit for specific search
                    include_details: true,
                };

                if (searchQuery) {
                    toolArgs.query = searchQuery;
                }

                const searchResult = await callTool('search_knowledge_graph', toolArgs);
                console.log('Search result:', searchResult);
                console.log('Search result type:', typeof searchResult);
                console.log('Search result keys:', searchResult ? Object.keys(searchResult) : 'null');
                
                // Handle null/undefined result
                if (!searchResult) {
                    throw new Error('No response from server');
                }

                // Check for error in response
                if (searchResult.error || searchResult.success === false) {
                    const errorMsg = searchResult.error || searchResult.message || 'Unknown error';
                    // Don't throw for empty results - that's valid
                    if (errorMsg.includes('too many clients') || errorMsg.includes('connection')) {
                        throw new Error(`Database connection issue: ${errorMsg}. The server may have too many connections open.`);
                    }
                    if (errorMsg.includes('fetch failed')) {
                        throw new Error(`Database query failed: ${errorMsg}. This may indicate connection pool exhaustion.`);
                    }
                    // For other errors, log but continue with empty results
                    console.warn('Knowledge graph search error:', errorMsg);
                    cachedDiscoveries = [];
                    updateDiscoveryFilterInfo(0);
                    updateDiscoveryLegend([]);
                    return false;
                }
                
                // Handle both array and object response formats
                let discoveries = [];
                if (Array.isArray(searchResult)) {
                    discoveries = searchResult;
                    console.log('Got array response with', discoveries.length, 'discoveries');
                } else if (searchResult.discoveries) {
                    discoveries = searchResult.discoveries;
                    console.log('Got discoveries array with', discoveries.length, 'items');
                } else if (searchResult.results) {
                    discoveries = searchResult.results;
                    console.log('Got results array with', discoveries.length, 'items');
                } else {
                    // Unexpected format - log and try to continue
                    console.warn('Unexpected response format:', searchResult);
                    discoveries = [];
                }

                // Sort by ID (which contains ISO timestamp) descending to get most recent first
                // ID format: "2025-12-29T08:34:42.201273" - lexicographically sortable
                discoveries.sort((a, b) => {
                    const aId = (a.id || '').trim();
                    const bId = (b.id || '').trim();
                    if (!aId && !bId) return 0;
                    if (!aId) return 1;  // No ID goes to end
                    if (!bId) return -1; // No ID goes to end
                    return bId.localeCompare(aId);
                });

                if (!searchQuery) {
                    // Only slice if we're doing a general load
                    discoveries = discoveries.slice(0, 50);
                }

                const enrichedDiscoveries = discoveries.map(d => {
                    // Parse date from id (format: "2025-12-29T08:34:42.201273" or "2026-01-01T23:40:53.202482")
                    // IDs use ISO timestamps - parse correctly
                    let dateStr = 'Unknown';
                    let dateObj = null;
                    if (d.id) {
                        try {
                            const isoStr = d.id.substring(0, 19);
                            const [datePart, timePart] = isoStr.split('T');
                            const [year, month, day] = datePart.split('-').map(Number);
                            const [hour, minute, second] = timePart.split(':').map(Number);
                            dateObj = new Date(year, month - 1, day, hour, minute, second || 0);

                            if (!isNaN(dateObj.getTime())) {
                                const now = new Date();
                                const diffMs = now - dateObj;
                                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                const month = monthNames[dateObj.getMonth()];
                                const day = dateObj.getDate();
                                const time = dateObj.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                                dateStr = `${month} ${day}, ${time}`;
                            } else {
                                dateStr = isoStr.replace('T', ' ');
                            }
                        } catch (e) {
                            dateStr = d.id.substring(0, 19).replace('T', ' ');
                        }
                    } else if (d.created_at) {
                        dateObj = new Date(d.created_at);
                        dateStr = !isNaN(dateObj.getTime()) ? dateObj.toLocaleString() : d.created_at;
                    } else if (d.timestamp) {
                        dateObj = new Date(d.timestamp);
                        dateStr = !isNaN(dateObj.getTime()) ? dateObj.toLocaleString() : d.timestamp;
                    }

                    const timestampMs = dateObj ? dateObj.getTime() : null;
                    return {
                        ...d,
                        _displayDate: dateStr,
                        _timestampMs: timestampMs,
                        _relativeTime: timestampMs ? formatRelativeTime(timestampMs) : null
                    };
                });

                cachedDiscoveries = enrichedDiscoveries;
                updateDiscoveryLegend(cachedDiscoveries);
                // Re-apply local filters (type/time) to the new search results
                applyDiscoveryFilters();
                return true;

            } catch (error) {
                const errorMsg = error.message || 'Unknown error';
                console.error('Failed to load discoveries:', error);
                
                // Show helpful error message
                let userMessage = `Failed to load discoveries: ${errorMsg}`;
                let isRetryable = false;
                
                if (errorMsg.includes('too many clients') || errorMsg.includes('connection pool') || errorMsg.includes('connection issue')) {
                    userMessage = 'Database connection pool exhausted. The server has too many open connections. Try refreshing in a moment or restart the server.';
                    isRetryable = true;
                } else if (errorMsg.includes('fetch failed') || errorMsg.includes('timeout')) {
                    userMessage = 'Database query timed out or failed. This may indicate connection issues. Try refreshing.';
                    isRetryable = true;
                } else if (errorMsg.includes('401') || errorMsg.includes('Authentication')) {
                    userMessage = 'Authentication required. Check if the server needs an API token.';
                } else if (errorMsg.includes('PostgreSQL') || errorMsg.includes('database')) {
                    userMessage = 'Database error. Check server logs for details.';
                    isRetryable = true;
                }
                
                // Show error banner if retryable
                if (isRetryable) {
                    updateConnectionBanner(true);
                }
                
                showError(userMessage);
                document.getElementById('discoveries-container').innerHTML =
                    `<div class="loading">${escapeHtml(userMessage)}<br><small>You can try refreshing or check the server status.</small></div>`;
                cachedDiscoveries = [];
                updateDiscoveryFilterInfo(0);
                updateDiscoveryLegend([]);
                
                // Still update count to show error state
                document.getElementById('discoveries-count').textContent = '?';
                document.getElementById('discoveries-change').innerHTML = 'Error loading';
                
                return false;
            }
        }

        // Cached dialectic sessions for filtering
        let cachedDialecticSessions = [];

        async function loadDialecticSessions() {
            try {
                console.log('Loading dialectic sessions...');
                const result = await callTool('list_dialectic_sessions', {
                    limit: 50,
                    include_transcript: false
                });

                console.log('Dialectic sessions result:', result);

                // Handle null/undefined result
                if (!result) {
                    throw new Error('No response from server');
                }

                // Check for error
                if (result.error || result.success === false) {
                    console.warn('Dialectic sessions error:', result.error || result.message);
                    updateDialecticDisplay([], 'Error loading');
                    return false;
                }

                // Extract sessions - minimal filtering, sort by date
                const rawSessions = result.sessions || [];
                const sessions = rawSessions
                    .sort((a, b) => {
                        // Sort by date descending (most recent first)
                        const dateA = new Date(a.created || 0);
                        const dateB = new Date(b.created || 0);
                        return dateB - dateA;
                    });
                cachedDialecticSessions = sessions;

                // Update stat card
                const sessionsEl = document.getElementById('dialectic-sessions');
                const changeEl = document.getElementById('dialectic-change');
                if (sessionsEl) {
                    sessionsEl.textContent = sessions.length;
                }
                if (changeEl) {
                    const resolved = sessions.filter(s => s.phase === 'resolved' || s.status === 'resolved').length;
                    const active = sessions.filter(s => !['resolved', 'failed'].includes(s.phase || s.status)).length;
                    changeEl.innerHTML = `${resolved} resolved, ${active} active`;
                }

                // Apply current filter (respects user's active filter selection)
                applyDialecticFilters();

                return true;
            } catch (error) {
                console.error('Error loading dialectic sessions:', error);
                updateDialecticDisplay([], 'Error loading');
                return false;
            }
        }

        function updateDialecticDisplay(sessions, message) {
            const sessionsEl = document.getElementById('dialectic-sessions');
            const changeEl = document.getElementById('dialectic-change');
            if (sessionsEl) {
                sessionsEl.textContent = sessions.length || '?';
            }
            if (changeEl) {
                changeEl.innerHTML = message || '';
            }
        }

        function updateDialecticFilterInfo(count) {
            const filterInfo = document.getElementById('dialectic-filter-info');
            if (filterInfo) {
                filterInfo.textContent = `Showing ${count} session${count !== 1 ? 's' : ''}`;
            }
        }

        function getPhaseColor(phase) {
            const colors = {
                'resolved': 'var(--accent-green)',
                'failed': 'var(--accent-orange)',
                'thesis': 'var(--accent-cyan)',
                'antithesis': 'var(--accent-purple)',
                'synthesis': 'var(--accent-yellow)'
            };
            return colors[phase] || 'var(--text-secondary)';
        }

        function formatDialecticPhase(phase) {
            const labels = {
                'resolved': 'Resolved',
                'failed': 'Failed',
                'thesis': 'Thesis',
                'antithesis': 'Antithesis',
                'synthesis': 'Synthesis'
            };
            return labels[phase] || phase || 'Unknown';
        }

        function renderDialecticList(sessions) {
            const container = document.getElementById('dialectic-container');
            if (!container) return;

            if (!sessions || sessions.length === 0) {
                container.innerHTML = `
                    <div class="dialectic-empty">
                        <div class="dialectic-empty-icon">ðŸ”„</div>
                        <div>No active dialectic sessions</div>
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.7">
                            Sessions appear when agents request recovery reviews
                        </div>
                    </div>`;
                return;
            }

            const escapeHtml = (str) => {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');
            };

            // Limit to 25 sessions for display
            const displaySessions = sessions.slice(0, 25);
            const hasMore = sessions.length > 25;

            container.innerHTML = displaySessions.map(session => {
                const phase = session.phase || session.status || 'unknown';
                const phaseColor = getPhaseColor(phase);
                const requestorId = session.paused_agent || session.requestor_id || session.agent_id || 'Unknown';
                const reviewerId = session.reviewer || session.reviewer_id || 'None';
                const sessionType = session.session_type || session.type || 'verification';
                const topic = session.topic || session.reason || `${sessionType} session`;
                const created = session.created || session.created_at || session.timestamp || '';

                // Format timestamp
                let timeAgo = '';
                if (created) {
                    try {
                        const date = new Date(created);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMins / 60);
                        const diffDays = Math.floor(diffHours / 24);

                        if (diffDays > 0) {
                            timeAgo = `${diffDays}d ago`;
                        } else if (diffHours > 0) {
                            timeAgo = `${diffHours}h ago`;
                        } else if (diffMins > 0) {
                            timeAgo = `${diffMins}m ago`;
                        } else {
                            timeAgo = 'Just now';
                        }
                    } catch (e) {
                        timeAgo = created;
                    }
                }

                // Resolution info
                let resolutionInfo = '';
                if (session.resolution) {
                    const res = session.resolution;
                    resolutionInfo = `<div class="dialectic-resolution">
                        Resolution: ${escapeHtml(res.action || res.type || 'Unknown')}
                        ${res.confidence ? ` (${(res.confidence * 100).toFixed(0)}% conf)` : ''}
                    </div>`;
                }

                return `
                    <div class="dialectic-item ${phase}" data-session-id="${session.session_id || ''}" style="cursor: pointer;" title="Click to view details">
                        <div class="dialectic-header">
                            <span class="dialectic-type" style="border-color: ${phaseColor}; color: ${phaseColor}">
                                ${escapeHtml(formatDialecticPhase(phase))}
                            </span>
                            <span class="dialectic-session-type">${escapeHtml(sessionType)}</span>
                            <span class="dialectic-time">${escapeHtml(timeAgo)}</span>
                        </div>
                        <div class="dialectic-topic">${escapeHtml(topic)}</div>
                        <div class="dialectic-agents">
                            <span class="agent-label">Requestor:</span> ${escapeHtml(requestorId.length > 15 ? requestorId.substring(0, 12) + '...' : requestorId)}
                            ${reviewerId && reviewerId !== 'None' ? `<span class="agent-label" style="margin-left: 10px;">Reviewer:</span> ${escapeHtml(reviewerId.length > 15 ? reviewerId.substring(0, 12) + '...' : reviewerId)}` : ''}
                            <span class="agent-label" style="margin-left: 10px; color: var(--accent-cyan);">ðŸ“ ${session.message_count || 0} messages</span>
                        </div>
                        ${resolutionInfo}
                    </div>
                `;
            }).join('');

            // Add "more" indicator if truncated
            if (hasMore) {
                container.innerHTML += `<div class="loading" style="text-align: center; padding: 10px;">
                    ...and ${sessions.length - 25} more sessions (use filter to narrow down)
                </div>`;
            }
        }

        function applyDialecticFilters() {
            const statusFilter = document.getElementById('dialectic-status-filter');
            const filter = statusFilter ? statusFilter.value : 'substantive';

            let filtered = cachedDialecticSessions;
            if (filter === 'substantive') {
                // Only sessions with real dialectic content (thesis+antithesis+synthesis = 3+ messages)
                filtered = cachedDialecticSessions.filter(s => (s.message_count || 0) >= 3);
            } else if (filter !== 'all') {
                filtered = cachedDialecticSessions.filter(s => {
                    const phase = s.phase || s.status || '';
                    if (filter === 'active') {
                        return ['thesis', 'antithesis', 'synthesis'].includes(phase);
                    }
                    return phase === filter;
                });
            }

            updateDialecticFilterInfo(filtered.length);
            renderDialecticList(filtered);
        }

        async function refresh(options = {}) {
            const force = options.force === true;
            if (autoRefreshPaused && !force) {
                return;
            }

            console.log('Refreshing dashboard...', { force, paused: autoRefreshPaused });

            // Don't auto-refresh if valid search text exists (to prevent overwriting search results)
            const searchInput = document.getElementById('discovery-search');
            if (searchInput && searchInput.value.trim().length > 0 && !force) {
                // Only refresh agents
                console.log('Search active, skipping discovery refresh');
                await loadAgents();
                await loadDialecticSessions();
                return;
            }

            clearError();
            const lastUpdateEl = document.getElementById('last-update');
            if (lastUpdateEl) {
                lastUpdateEl.textContent = new Date().toLocaleTimeString();
            }

            try {
                console.log('Starting parallel load...');
                const results = await Promise.allSettled([
                    loadAgents(),
                    loadDiscoveries(),
                    loadDialecticSessions()
                ]);
                console.log('Load results:', results);
                
                // Check if critical operations failed (agents and discoveries)
                const agentsResult = results[0];
                const discoveriesResult = results[1];
                const dialecticResult = results[2];
                
                const criticalFailures = [
                    agentsResult.status === 'rejected' || (agentsResult.status === 'fulfilled' && agentsResult.value === false),
                    discoveriesResult.status === 'rejected' || (discoveriesResult.status === 'fulfilled' && discoveriesResult.value === false)
                ].filter(Boolean).length;
                
                // Only show connection banner if BOTH critical operations failed
                // This prevents false positives from transient errors
                if (criticalFailures >= 2) {
                    updateConnectionBanner(true);
                    console.warn('Critical operations failed:', {
                        agents: agentsResult.status,
                        discoveries: discoveriesResult.status
                    });
                } else {
                    updateConnectionBanner(false);
                }
                
                // Log any individual failures
                results.forEach((result, index) => {
                    if (result.status === 'rejected') {
                        console.error(`Load operation ${index} failed:`, result.reason);
                    }
                });
            } catch (error) {
                // This should rarely happen since we're using Promise.allSettled
                updateConnectionBanner(true);
                console.error('Refresh error:', error);
                showError(`Refresh failed: ${error.message}`);
            }
        }

        const agentSearchInput = document.getElementById('agent-search');
        const agentStatusFilterInput = document.getElementById('agent-status-filter');
        const agentMetricsOnlyInput = document.getElementById('agent-metrics-only');
        if (agentSearchInput) {
            agentSearchInput.addEventListener('input', applyAgentFilters);
        }
        if (agentStatusFilterInput) {
            agentStatusFilterInput.addEventListener('change', applyAgentFilters);
        }
        if (agentMetricsOnlyInput) {
            agentMetricsOnlyInput.addEventListener('change', applyAgentFilters);
        }
        const agentClearFiltersButton = document.getElementById('agent-clear-filters');
        if (agentClearFiltersButton) {
            agentClearFiltersButton.addEventListener('click', clearAgentFilters);
        }

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const discoverySearchInput = document.getElementById('discovery-search');
        const discoveryTypeFilterInput = document.getElementById('discovery-type-filter');
        const discoveryTimeFilterInput = document.getElementById('discovery-time-filter');

        // Debounced search handler
        const handleDiscoverySearch = debounce(async (e) => {
            const query = e.target.value.trim();
            // Call server search
            await loadDiscoveries(query);
        }, 500); // 500ms debounce

        if (discoverySearchInput) {
            // Apply local highlighting immediately
            discoverySearchInput.addEventListener('input', applyDiscoveryFilters);
            // Trigger server search after delay
            discoverySearchInput.addEventListener('input', handleDiscoverySearch);
        }
        if (discoveryTypeFilterInput) {
            discoveryTypeFilterInput.addEventListener('change', applyDiscoveryFilters);
        }
        if (discoveryTimeFilterInput) {
            discoveryTimeFilterInput.addEventListener('change', applyDiscoveryFilters);
        }
        const discoveryClearFiltersButton = document.getElementById('discovery-clear-filters');
        if (discoveryClearFiltersButton) {
            discoveryClearFiltersButton.addEventListener('click', () => {
                clearDiscoveryFilters();
                // Reset to full list from server
                loadDiscoveries('');
            });
        }
        const discoveryLegend = document.getElementById('discoveries-type-legend');
        if (discoveryLegend && discoveryTypeFilterInput) {
            discoveryLegend.addEventListener('click', event => {
                const chip = event.target.closest('.discovery-type');
                if (!chip) return;
                const type = chip.getAttribute('data-type');
                if (!type) return;
                discoveryTypeFilterInput.value = type;
                applyDiscoveryFilters();
            });
        }

        const refreshNowButton = document.getElementById('refresh-now');
        const pauseRefreshInput = document.getElementById('pause-refresh');
        if (refreshNowButton) {
            refreshNowButton.addEventListener('click', () => refresh({ force: true }));
        }
        if (pauseRefreshInput) {
            pauseRefreshInput.addEventListener('change', event => {
                autoRefreshPaused = event.target.checked;
                updateRefreshStatus();
            });
        }
        updateRefreshStatus();

        const agentsContainer = document.getElementById('agents-container');
        if (agentsContainer) {
            agentsContainer.addEventListener('click', event => {
                const button = event.target.closest('button[data-action="copy-id"]');
                if (!button) return;
                const agentId = button.getAttribute('data-agent-id');
                if (!agentId) return;
                copyToClipboard(agentId)
                    .then(() => {
                        const originalLabel = button.textContent;
                        button.textContent = 'Copied';
                        setTimeout(() => {
                            button.textContent = originalLabel;
                        }, 1500);
                    })
                    .catch(() => {
                        const originalLabel = button.textContent;
                        button.textContent = 'Copy failed';
                        setTimeout(() => {
                            button.textContent = originalLabel;
                        }, 1500);
                    });
            });
        }

        const agentsLegend = document.getElementById('agents-status-legend');
        if (agentsLegend && agentStatusFilterInput) {
            agentsLegend.addEventListener('click', event => {
                const chip = event.target.closest('.status-chip');
                if (!chip) return;
                const status = chip.getAttribute('data-status');
                if (!status) return;
                agentStatusFilterInput.value = status;
                applyAgentFilters();
            });
        }

        // Dialectic sessions event listeners
        const dialecticStatusFilter = document.getElementById('dialectic-status-filter');
        const dialecticRefreshButton = document.getElementById('dialectic-refresh');
        if (dialecticStatusFilter) {
            dialecticStatusFilter.addEventListener('change', applyDialecticFilters);
        }
        if (dialecticRefreshButton) {
            dialecticRefreshButton.addEventListener('click', async () => {
                dialecticRefreshButton.disabled = true;
                dialecticRefreshButton.textContent = 'Loading...';
                try {
                    await loadDialecticSessions();
                } finally {
                    dialecticRefreshButton.disabled = false;
                    dialecticRefreshButton.textContent = 'Refresh';
                }
            });
        }

        // Click handler for dialectic items to show full details
        const dialecticContainer = document.getElementById('dialectic-container');
        if (dialecticContainer) {
            dialecticContainer.addEventListener('click', (event) => {
                const item = event.target.closest('.dialectic-item');
                if (!item) return;
                const sessionId = item.getAttribute('data-session-id');
                if (!sessionId) return;

                const session = cachedDialecticSessions.find(s => s.session_id === sessionId);
                if (!session) return;
                showDialecticDetail(session);
            });
        }

        // Click handler for discovery items to show full details
        const discoveriesContainer = document.getElementById('discoveries-container');
        if (discoveriesContainer) {
            discoveriesContainer.addEventListener('click', (event) => {
                const item = event.target.closest('.discovery-item');
                if (!item) return;
                const index = parseInt(item.getAttribute('data-discovery-index'), 10);
                if (isNaN(index) || index < 0 || index >= cachedDiscoveries.length) return;

                const discovery = cachedDiscoveries[index];
                showDiscoveryDetail(discovery);
            });
        }

        function showDiscoveryDetail(discovery) {
            const modal = document.getElementById('panel-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            if (!modal || !modalTitle || !modalBody) return;

            const type = normalizeDiscoveryType(discovery.type || discovery.discovery_type || 'note');
            const typeLabel = formatDiscoveryType(type);
            const agent = discovery.by || discovery.agent_id || discovery._agent_id || 'Unknown';
            const summary = discovery.summary || 'Untitled';
            const details = discovery.details || discovery.content || discovery.discovery || '';
            const displayDate = discovery._displayDate || 'Unknown';
            const relativeTime = discovery._relativeTime || '';

            let html = `
                <div class="discovery-detail">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                        <span class="discovery-type ${type}" style="font-size: 1em;">${escapeHtml(typeLabel)}</span>
                        <span style="color: var(--text-secondary);">${escapeHtml(displayDate)}${relativeTime ? ` (${relativeTime})` : ''}</span>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <strong style="color: var(--text-secondary);">Summary:</strong><br>
                        <span style="font-size: 1.1em;">${escapeHtml(summary)}</span>
                    </div>

                    ${details ? `
                        <div style="margin-bottom: 15px;">
                            <strong style="color: var(--text-secondary);">Details:</strong>
                            <div style="margin-top: 8px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.95em; max-height: 300px; overflow-y: auto;">
${escapeHtml(details)}</div>
                        </div>
                    ` : ''}

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div>
                            <strong style="color: var(--text-secondary);">Agent:</strong><br>
                            <code style="font-size: 0.9em; word-break: break-all;">${escapeHtml(agent)}</code>
                        </div>
                        ${discovery.id ? `
                            <div>
                                <strong style="color: var(--text-secondary);">ID:</strong><br>
                                <code style="font-size: 0.85em; word-break: break-all;">${escapeHtml(discovery.id)}</code>
                            </div>
                        ` : ''}
                    </div>

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">Raw data</summary>
                        <pre style="font-size: 0.75em; max-height: 200px; overflow: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 8px;">${escapeHtml(JSON.stringify(discovery, null, 2))}</pre>
                    </details>
                </div>`;

            modalTitle.textContent = `Discovery: ${typeLabel}`;
            modalBody.innerHTML = html;
            modal.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }

        async function showDialecticDetail(session) {
            const modal = document.getElementById('panel-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            if (!modal || !modalTitle || !modalBody) return;

            const sessionId = session.session_id || 'Unknown';
            const phase = session.phase || session.status || 'unknown';

            // Show modal with loading state
            modalTitle.textContent = `Dialectic Session: ${formatDialecticPhase(phase)}`;
            modalBody.innerHTML = `<div class="loading">Loading full session details...</div>`;
            modal.classList.add('visible');
            document.body.style.overflow = 'hidden';

            // Try to fetch full session with transcript
            let fullSession = session;
            if (sessionId && sessionId !== 'Unknown') {
                try {
                    const result = await callTool('get_dialectic_session', {
                        session_id: sessionId,
                        check_timeout: false
                    });
                    if (result && result.session) {
                        fullSession = result.session;
                    } else if (result && !result.error) {
                        fullSession = result;
                    }
                } catch (e) {
                    console.warn('Failed to fetch full session, using cached:', e);
                }
            }

            // Render with potentially full data
            renderDialecticDetailContent(modalBody, fullSession);
        }

        function renderDialecticDetailContent(container, session) {
            const phase = session.phase || session.status || 'unknown';
            const phaseColor = getPhaseColor(phase);
            const requestorId = session.paused_agent || session.requestor_id || session.agent_id || 'Unknown';
            const reviewerId = session.reviewer || session.reviewer_id || 'None';
            const sessionType = session.session_type || session.type || 'verification';
            const topic = session.topic || session.reason || `${sessionType} session`;
            const sessionId = session.session_id || 'Unknown';
            const created = session.created || session.created_at || session.timestamp || '';

            // Build full details HTML
            let html = `
                <div class="dialectic-detail">
                    <div class="dialectic-detail-header">
                        <span class="dialectic-type" style="border-color: ${phaseColor}; color: ${phaseColor}; font-size: 1.1em;">
                            ${escapeHtml(formatDialecticPhase(phase))}
                        </span>
                        <span class="dialectic-session-type" style="font-size: 1em;">${escapeHtml(sessionType)}</span>
                    </div>

                    <div style="margin: 15px 0;">
                        <strong style="color: var(--text-secondary);">Topic:</strong><br>
                        <span style="font-size: 1.1em;">${escapeHtml(topic)}</span>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div>
                            <strong style="color: var(--text-secondary);">Session ID:</strong><br>
                            <code style="font-size: 0.85em; word-break: break-all;">${escapeHtml(sessionId)}</code>
                        </div>
                        <div>
                            <strong style="color: var(--text-secondary);">Created:</strong><br>
                            ${escapeHtml(created)}
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div>
                            <strong style="color: var(--text-secondary);">Requestor:</strong><br>
                            <code style="font-size: 0.9em; word-break: break-all;">${escapeHtml(requestorId)}</code>
                        </div>
                        <div>
                            <strong style="color: var(--text-secondary);">Reviewer:</strong><br>
                            ${reviewerId !== 'None' ? `<code style="font-size: 0.9em; word-break: break-all;">${escapeHtml(reviewerId)}</code>` : '<span style="color: var(--text-secondary);">Not assigned</span>'}
                        </div>
                    </div>`;

            // Add resolution if present
            if (session.resolution) {
                const res = session.resolution;
                html += `
                    <div style="margin: 15px 0; padding: 10px; background: rgba(0,100,0,0.2); border-radius: 6px; border-left: 3px solid var(--accent-green);">
                        <strong style="color: var(--accent-green);">Resolution:</strong><br>
                        <span>Action: ${escapeHtml(res.action || res.type || 'Unknown')}</span>
                        ${res.confidence ? `<br>Confidence: ${(res.confidence * 100).toFixed(0)}%` : ''}
                        ${res.reason ? `<br>Reason: ${escapeHtml(res.reason)}` : ''}
                    </div>`;
            }

            // Add transcript - this is the key data we want to show
            const transcript = session.transcript || [];
            if (transcript.length > 0) {
                html += `
                    <div style="margin: 15px 0;">
                        <strong style="color: var(--accent-cyan);">Discussion Transcript (${transcript.length} messages):</strong>
                        <div style="margin-top: 10px; max-height: 350px; overflow-y: auto;">
                            ${transcript.map((entry, idx) => {
                                const role = entry.role || entry.agent_id || entry.phase || 'system';
                                const content = entry.content || entry.reasoning || entry.message || '';
                                const timestamp = entry.timestamp || '';
                                const isSystem = role === 'system' || role === 'synthesis';
                                const roleColor = isSystem ? 'var(--accent-yellow)' : 'var(--accent-cyan)';

                                return `
                                    <div style="margin-bottom: 12px; padding: 10px 12px; background: rgba(0,0,0,0.25); border-radius: 6px; border-left: 2px solid ${roleColor};">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                            <strong style="color: ${roleColor}; text-transform: uppercase; font-size: 0.8em;">${escapeHtml(role)}</strong>
                                            ${timestamp ? `<span style="color: var(--text-secondary); font-size: 0.75em;">${escapeHtml(timestamp)}</span>` : ''}
                                        </div>
                                        <div style="color: var(--text-primary); white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; line-height: 1.5;">${escapeHtml(content)}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>`;
            } else {
                html += `
                    <div style="margin: 15px 0; padding: 20px; background: rgba(0,0,0,0.15); border-radius: 6px; text-align: center; color: var(--text-secondary);">
                        <div style="font-size: 1.5em; margin-bottom: 8px;">ðŸ“­</div>
                        No transcript recorded for this session.<br>
                        <small>This may be an auto-resolved or system-generated session.</small>
                    </div>`;
            }

            // Show raw JSON for debugging
            html += `
                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; color: var(--text-secondary);">Raw session data</summary>
                    <pre style="font-size: 0.75em; max-height: 200px; overflow: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 8px;">${escapeHtml(JSON.stringify(session, null, 2))}</pre>
                </details>
                </div>`;

            container.innerHTML = html;
        }

        // Theme toggle
        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const themeLabel = document.getElementById('theme-label');
        if (themeToggle && themeManager) {
            themeToggle.addEventListener('click', () => {
                const newTheme = themeManager.toggle();
                if (themeIcon) themeIcon.textContent = newTheme === 'dark' ? 'ðŸŒ™' : 'â˜€ï¸';
                if (themeLabel) themeLabel.textContent = newTheme === 'dark' ? 'Dark' : 'Light';
            });
            // Set initial icon
            const currentTheme = themeManager.getTheme();
            if (themeIcon) themeIcon.textContent = currentTheme === 'dark' ? 'ðŸŒ™' : 'â˜€ï¸';
            if (themeLabel) themeLabel.textContent = currentTheme === 'dark' ? 'Dark' : 'Light';
        } else if (themeToggle) {
            // Hide theme toggle if themeManager not available
            themeToggle.style.display = 'none';
        }


        // Export functionality
        function exportAgents(format) {
            if (cachedAgents.length === 0) {
                showError('No agents to export');
                return;
            }

            const exportData = cachedAgents.map(agent => ({
                agent_id: agent.agent_id || '',
                name: getAgentDisplayName(agent),
                status: getAgentStatus(agent),
                E: agent.metrics?.E || null,
                I: agent.metrics?.I || null,
                S: agent.metrics?.S || null,
                V: agent.metrics?.V || null,
                coherence: agent.metrics?.coherence || null,
                last_update: agent.last_update || '',
                created_at: agent.created_at || ''
            }));

            if (format === 'csv') {
                if (typeof DataProcessor !== 'undefined' && DataProcessor.exportToCSV) {
                    DataProcessor.exportToCSV(exportData, `agents_${new Date().toISOString().split('T')[0]}.csv`);
                } else {
                    // Fallback CSV export
                    const headers = Object.keys(exportData[0]);
                    const csv = [
                        headers.join(','),
                        ...exportData.map(row => headers.map(h => {
                            const v = row[h];
                            return v === null || v === undefined ? '' : String(v).replace(/"/g, '""');
                        }).join(','))
                    ].join('\n');
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agents_${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            } else {
                if (typeof DataProcessor !== 'undefined' && DataProcessor.exportToJSON) {
                    DataProcessor.exportToJSON(exportData, `agents_${new Date().toISOString().split('T')[0]}.json`);
                } else {
                    // Fallback JSON export
                    const json = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agents_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }

        function exportDiscoveries(format) {
            if (cachedDiscoveries.length === 0) {
                showError('No discoveries to export');
                return;
            }

            const exportData = cachedDiscoveries.map(d => ({
                id: d.id || '',
                type: d.type || d.discovery_type || 'note',
                summary: d.summary || '',
                content: d.details || d.content || d.discovery || '',
                agent: d.by || d.agent_id || d._agent_id || '',
                timestamp: d._timestampMs ? new Date(d._timestampMs).toISOString() : ''
            }));

            if (format === 'csv') {
                if (typeof DataProcessor !== 'undefined' && DataProcessor.exportToCSV) {
                    DataProcessor.exportToCSV(exportData, `discoveries_${new Date().toISOString().split('T')[0]}.csv`);
                } else {
                    // Fallback CSV export
                    const headers = Object.keys(exportData[0]);
                    const csv = [
                        headers.join(','),
                        ...exportData.map(row => headers.map(h => {
                            const v = row[h];
                            return v === null || v === undefined ? '' : String(v).replace(/"/g, '""');
                        }).join(','))
                    ].join('\n');
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `discoveries_${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            } else {
                if (typeof DataProcessor !== 'undefined' && DataProcessor.exportToJSON) {
                    DataProcessor.exportToJSON(exportData, `discoveries_${new Date().toISOString().split('T')[0]}.json`);
                } else {
                    // Fallback JSON export
                    const json = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `discoveries_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }

        const exportAgentsCsv = document.getElementById('export-agents-csv');
        const exportAgentsJson = document.getElementById('export-agents-json');
        const exportDiscoveriesCsv = document.getElementById('export-discoveries-csv');
        const exportDiscoveriesJson = document.getElementById('export-discoveries-json');

        if (exportAgentsCsv) exportAgentsCsv.addEventListener('click', () => exportAgents('csv'));
        if (exportAgentsJson) exportAgentsJson.addEventListener('click', () => exportAgents('json'));
        if (exportDiscoveriesCsv) exportDiscoveriesCsv.addEventListener('click', () => exportDiscoveries('csv'));
        if (exportDiscoveriesJson) exportDiscoveriesJson.addEventListener('click', () => exportDiscoveries('json'));

        // Initial load - wait a bit for scripts to load
        console.log('Dashboard initializing...');
        console.log('API available:', typeof api !== 'undefined' && api !== null);
        console.log('DataProcessor available:', typeof DataProcessor !== 'undefined');
        console.log('ThemeManager available:', typeof themeManager !== 'undefined' && themeManager !== null);
        
        // Wait for DOM to be ready and scripts to potentially load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('DOM ready, starting initial load');
                setTimeout(() => {
                    refresh();
                }, 100);
            });
        } else {
            console.log('DOM already ready, starting initial load');
            setTimeout(() => {
                refresh();
            }, 100);
        }

        // Auto-refresh every 10 seconds (reduced from 5 to avoid rate limits)
        setInterval(() => {
            if (!autoRefreshPaused) {
                refresh();
            }
        }, REFRESH_INTERVAL_MS);
    </script>
</body>

</html>